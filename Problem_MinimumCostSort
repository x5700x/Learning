题目：
输入：第一行输入货物数量n，第二行输入各货物质量m（n <= 1000,m<= 10000)
将货物按重量升排好，排序时使用两两货物交换的方法，交换过程消耗能量为m1 + m2.请求出消耗最少的排序方法
输出：最小消耗

#include<iostream>
#include<algorithm>
using namespace std;
int Min(int x, int y)
{
	if (x <= y)
		return x;
	else
		return y;
}
int Max(int x, int y)
{
	if (x >= y)
		return x;
	else
		return y;
}
//原理：选一个不在正确位置的元素，跳往正确位置，其正确位置原本的元素重复此操作，最终会首尾相连使一部分元素都到正确位置，形成一个圆，题目想对所有元素排位，会形成n个圆；
//为了节省资源，选择一个圆中最小的元素，让它占据的地方换为该地的正确元素，这样消耗最小，较大的那个正确元素到了正确位置，最小元素到了另一个不正确位置，继续此交换,直到最小元素到正确位置，所有元素都到了正确位置
//当最小元素回到正确位置，发现消耗为 货物重量和 + （n - 2) * 最小元素
//特殊情况：一个圆中最小元素过大，可将数组中最小元素接过来进行操作，最后消耗为 货物重量和 + 局部最小值 + （n + 1）* 数组最小值


int main()
{
	int n, min = 10000;     //min-数组最小值		
	int* A, * B;         //A，B分别储存原始数组和排序后数组
	bool C[1000] = { 0 };//无需输出，用C标记该位置是否已经调换，省去交换操作
	int T[10001];//T记录A中各元素在B中位置（数据最大值为10000），元素上限过大时，考虑用lower_bound在B中找到迭代器来减去头迭代器获取位置；
	int ans = 0;
	cin >> n;
	A = new int[n];
	B = new int[n];
	for (int i = 0; i < n; i++)
	{
		cin >> A[i];
		B[i] = A[i];
		min = Min(min, A[i]);
	}
	sort(B, B + n);
	for (int i = 0; i < n; i++)
	{
		T[B[i]] = i;  // 记录B中各元素位置，T的[]放入货物得到货物的正确位置，在key是整数且大小有限时，直接用散列法存储位置
	}
	for (int i = 0; i < n; i++) // 遍历
	{
		if (!C[i] && A[i] != B[i])
		{
			int c = 0; //圆中个数
			int s = 0; //货物重量和
			int m = 10000;//局部最小
			int tmp = i; //位置指针
			while (!C[tmp])
			{
				C[tmp] = true;
				c++;
				m = Min(m, A[tmp]);
				s += A[tmp];
				tmp = T[A[tmp]];
			}
			ans += Min(s + (c - 2) * m, m + s + (c + 1) * min); //哪种方法消耗小直接函数比较
		}

	}
	cout << ans;
}
